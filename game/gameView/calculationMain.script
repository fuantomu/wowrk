function init(self)

end

function final(self)
	-- Add finalization code here
	-- Remove this function if not needed
end

function update(self, dt)
	-- Add update code here
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	if(message_id == hash("getAttackResult")) then
		if(message.type == "autoAttack") then
			local eDefSkill = message.e["level"] * 5
			local eWpnSkill = eDefSkill
			local pWpnSkill = message.p["stats"]["skill"][message.p["weapon"]["wtype"]]
			local pCritChance = message.p["stats"]["crit"]
			local eAvoidance = message.e["avoidance"]
			--print(eDefSkill, pWpnSkill)
			local pHitChance = calculateHitChance(pWpnSkill, eDefSkill, message.dw)
			--print(pHitChance)
			local pAttackTable = generateAttackTable(pWpnSkill, pHitChance, pCritChance, eWpnSkill, eDefSkill, eAvoidance, message.ranged, message.front, message.gb, message.cb)
			--tprint(pAttackTable)
			local pAttackResult = getAttackResult(pAttackTable)
			print(pAttackResult)

			if not(pAttackResult == "block" or pAttackResult == "miss" or pAttackResult == "dodge" or pAttackResult == "parry") then
				local damageMult = 1
				local damageRolls = getRandomDamage(message.p["weapon"]["schools"])

				if(pAttackResult == "glancingBlow") then
					damageMult = math.min(math.max(0.7, 0.7 + (math.min(pWpnSkill, 310) - eDefSkill) * 0.03), 1)
				elseif(pAttackResult == "crit") then
					damageMult = 2
				end
				print("Testing AutoAttack with "..damageRolls["phy"].." * "..damageMult.." damage")
			else
				print("Testing AutoAttack: "..pAttackResult)
			end
		end
	elseif(message_id == hash("getStats")) then
		tprint(message.p["stats"])
		calculateStats(message.p["stats"], message.e)
		tprint(message.p["stats"])
	end
end

function calculateStats(pStats, eStats)
	pStats["maxHp"] = pStats["basehp"] + math.min(pStats["attr"]["sta"], 20) + 10 * math.max(0, (pStats["attr"]["sta"]-20))
end

function calculateHitChance(pWpnSkill, eDefSkill, dualWield)
	local rHitChance = 100
	local baseMiss = 5
	if(dualWield == true) then
		baseMiss = 24
	end
	if(eDefSkill - pWpnSkill > 10) then
		rHitChance = math.max(0,100 - ((baseMiss + 2) + (eDefSkill - pWpnSkill - 10) * 0.4))
	else
		rHitChance = math.max(0,100 - (baseMiss + (eDefSkill - pWpnSkill) * 0.1))
	end
	return rHitChance
end

function generateAttackTable(pWpnSkill, pHitChance, pCritChance, eWpnSkill, eDefSkill, eAvoidance, ranged, attackFront, gbEnabled, cbEnabled)
	local rollTable = {miss=0,dodge=0,parry=0,glancingBlow=0,block=0,crit=0,crushingBlow=0,hit=0}
	local remainingRolls = math.max(0, pHitChance)
	local tempVar = 100
	rollTable["miss"] = math.max(0, tempVar - remainingRolls)
	tempVar = remainingRolls
	if(ranged == false) then
		remainingRolls = math.max(0, remainingRolls - eAvoidance["dodge"])
		rollTable["dodge"] = tempVar - remainingRolls
		tempVar = remainingRolls
	end
	if(attackFront == true and ranged == false) then
		remainingRolls = math.max(0, remainingRolls - eAvoidance["parry"])
		rollTable["parry"] = tempVar - remainingRolls
		tempVar = remainingRolls
	end
	if(gbEnabled == true and ranged == false) then
		remainingRolls = math.max(0, remainingRolls - math.max(0, 10 + (eDefSkill - math.min(pWpnSkill, 300))) * 2)
		rollTable["glancingBlow"] = tempVar - remainingRolls
		tempVar = remainingRolls
	end
	if(attackFront == true) then
		remainingRolls = math.max(0, remainingRolls - eAvoidance["block"])
		rollTable["block"] = tempVar - remainingRolls
		tempVar = remainingRolls
	end
	remainingRolls = math.max(0, remainingRolls - ((pHitChance + rollTable["miss"]) * (pCritChance/100)))
	rollTable["crit"] = tempVar - remainingRolls
	tempVar = remainingRolls
	if(cbEnabled == true) then
		remainingRolls = math.max(0, remainingRolls - (((eWpnSkill - pDefSkill) * 2) - 15))
		rollTable["crushingBlow"] = remainingRolls
	end
	rollTable["hit"] = remainingRolls
	return rollTable
end

function getAttackResult(attackTable)
	local rngRanges =math.floor(math.random()*100)
	local weight = 0
	local tableOrder = {"miss","dodge","parry","glancingBlow","block","crit","crushingBlow","hit"}
	for i = 1, #tableOrder do
		weight = weight + attackTable[tableOrder[i]]
		print(rngRanges,weight,attackTable[tableOrder[i]], tableOrder[i])
		if(rngRanges <= weight) then
			return tableOrder[i]
		end
	end
end

function calculateDamage(pDmgRange, pDmgReduction)
	--local wpnDmg = getDamage(self.playerWeapon[message.player]["damage"])
	pDmgRange["phy"] =  pDmgRange["phy"] * pDmgReduction --(1-(self.bossStats["armor"] / (self.bossStats["armor"] + 400 + 85 * self.bossStats["level"])))
	local damageDone = wpnDmg["phy"] + wpnDmg["fire"] + wpnDmg["frost"] + wpnDmg["arcane"] + wpnDmg["nature"] + wpnDmg["shadow"] + wpnDmg["holy"]
	if(message.type == "Attack") then
		damageDone = damageDone + (self.playerStats[message.player]["ap"] / 14)
		damageDone = math.floor(0.5 + damageDone)
		msg.post("/spritePlayer#spriteP".. message.player, "play_animation", { id = hash("attack") })
		print("Player "..message.player.." hit: "..damageDone.."["..wpnDmg["phy"]..","..wpnDmg["fire"]..","..wpnDmg["frost"]..","..wpnDmg["arcane"]..","..wpnDmg["nature"]..","..wpnDmg["shadow"]..","..wpnDmg["holy"].."]")
	end
end

function calculateDamageReduction(cLevel, cArmor, eLevel)
	reductionPercentage = 0
	if(cLevel < 60) then
		reductionPercentage = min( cArmor / ( cArmor + 400 + 85 * eLevel), 75)
	elseif(cLevel >= 60) then
		reductionPercentage = min( cArmor / ( cArmor + 400 + 85 * ( eLevel + 4.5 * ( eLevel - 59))) , 75)
	end
	print("DR test: character level: "..cLevel.." ; character Armor: "..cArmor.." ; enemy level: "..eLevel.." ; DR%: "..reductionPercentage)
	return reductionPercentage
end


function getRandomDamage(weapon)
	local physDamage, fireDamage, frostDamage, arcaneDamage, natureDamage, shadowDamage, holyDamage = 0,0,0,0,0,0,0
	local schools = {"Physical","Fire","Frost","Arcane","Holy","Shadow","Nature"}
	for i = 1, #schools do
		if(schools[i] == "Physical") then
			physDamage = math.random(tonumber(weapon[schools[i]]["min"]) , tonumber(weapon[schools[i]]["max"]))
		elseif(schools[i] == "Fire") then
			fireDamage = math.random(tonumber(weapon[schools[i]]["min"]) , tonumber(weapon[schools[i]]["max"]))
		elseif(schools[i] == "Frost") then
			frostDamage = math.random(tonumber(weapon[schools[i]]["min"]) , tonumber(weapon[schools[i]]["max"]))
		elseif(schools[i] == "Arcane") then
			arcaneDamage = math.random(tonumber(weapon[schools[i]]["min"]) , tonumber(weapon[schools[i]]["max"]))
		elseif(schools[i] == "Nature") then
			natureDamage = math.random(tonumber(weapon[schools[i]]["min"]) , tonumber(weapon[schools[i]]["max"]))
		elseif(schools[i] == "Shadow") then
			shadowDamage = math.random(tonumber(weapon[schools[i]]["min"]) , tonumber(weapon[schools[i]]["max"]))
		elseif(schools[i] == "Holy") then
			holyDamage = math.random(tonumber(weapon[schools[i]]["min"]) , tonumber(weapon[schools[i]]["max"]))
		end
	end
	return {phy=physDamage, fire=fireDamage,frost=frostDamage,arcane=arcaneDamage,nature=natureDamage,shadow=shadowDamage,holy=holyDamage}
end

function tprint (t, s)
	for k, v in pairs(t) do
		local kfmt = '["' .. tostring(k) ..'"]'
		if type(k) ~= 'string' then
			kfmt = '[' .. k .. ']'
		end
		local vfmt = '"'.. tostring(v) ..'"'
		if type(v) == 'table' then
			tprint(v, (s or '')..kfmt)
		else
			if type(v) ~= 'string' then
				vfmt = tostring(v)
			end
			print(type(t)..(s or '')..kfmt..' = '..vfmt)
		end
	end
end