function init(self)

end

function final(self)
	-- Add finalization code here
	-- Remove this function if not needed
end

function update(self, dt)
	-- Add update code here
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	if(message_id == hash("getAttackResult")) then
		local eDefSkill = message.e["level"] * 5
		local eWpnSkill = eDefSkill
		local pWpnSkill = message.p["stats"]["skill"][message.p["weapon"]["wtype"]]
		local pCritChance = message.p["stats"]["crit"]
		local eAvoidance = message.e["avoidance"]
		print(eDefSkill, pWpnSkill)
		local pHitChance = calculateHitChance(pWpnSkill, eDefSkill, message.dw)
		print(pHitChance)
		local pAttackTable = generateAttackTable(pWpnSkill, pHitChance, pCritChance, eWpnSkill, eDefSkill, eAvoidance, message.special, message.ranged, message.front,message.block, message.mob)
		tprint(pAttackTable)
		local pAttackResult = getAttackResult(pAttackTable)
		print(pAttackResult)

		if not(pAttackResult == "block" or pAttackResult == "miss" or pAttackResult == "dodge" or pAttackResult == "parry") then
			local damageMult = 1
			local damageRolls = getRandomDamage(message.p["weapon"]["schools"])

			if(pAttackResult == "glancingBlow") then
				damageMult =  math.max(0.40,1 - math.abs(math.min(0,5 + pWpnSkill - eDefSkill) * 0.03))
			elseif(pAttackResult == "crit") then
				damageMult = 2
			end
			print("Testing attack with "..damageRolls["phy"].." * "..damageMult.." damage")
		else
			print("Testing attack: "..pAttackResult)
		end
	elseif(message_id == hash("getStats")) then
		calculateStats(message.p["stats"], message.p["weapon"], message.e)
		msg.post(sender, hash("returnStats"), {p=message.p, e=message.e})
	end
end

function calculateStats(pStats, pWpn, eStats)
	pStats["maxHp"] = pStats["basehp"] + math.min(pStats["attr"]["sta"], 20) + 10 * math.max(0, (pStats["attr"]["sta"]-20))
	
end

function calculateHitChance(pWpnSkill, eDefSkill, dualWield)
	local rHitChance = 100
	local baseMiss = 5.6
	if(dualWield == true) then
		baseMiss = baseMiss + 19
	end
	if(eDefSkill - pWpnSkill > 10) then
		rHitChance = math.max(0,100 - ((baseMiss + 1) + (eDefSkill - pWpnSkill - 10) * 0.4))
	else
		rHitChance = math.max(0,100 - (baseMiss + (eDefSkill - pWpnSkill) * 0.1))
	end
	return rHitChance
end

function generateAttackTable(pWpnSkill, pHitChance, pCritChance, eWpnSkill, eDefSkill, eAvoidance, special, ranged, attackFront, blockEnabled, isMob)
	local rollTable = {miss=0,dodge=0,parry=0,glancingBlow=0,block=0,crit=0,crushingBlow=0,hit=0}
	local pSkillDifference = math.max(0,eDefSkill - pWpnSkill)

	
	local remainingRolls = math.max(0, pHitChance)
	local tempVar = 100
	rollTable["miss"] = math.max(0, tempVar - remainingRolls)
	tempVar = remainingRolls
	if(ranged == false) then
		eAvoidance["dodge"] = eAvoidance["dodge"] + pSkillDifference * 0.04
		remainingRolls = math.max(0, remainingRolls - eAvoidance["dodge"])
		rollTable["dodge"] = tempVar - remainingRolls
		tempVar = remainingRolls
	end
	if(attackFront == true and ranged == false) then
		eAvoidance["parry"] = eAvoidance["parry"] + pSkillDifference * 0.04
		remainingRolls = math.max(0, remainingRolls - eAvoidance["parry"])
		rollTable["parry"] = tempVar - remainingRolls
		tempVar = remainingRolls
	end
	if(isMob == false and ranged == false and special == false) then
		remainingRolls = math.max(0, remainingRolls - math.max(0, 10 + (eDefSkill - math.min(pWpnSkill, 300)) * 2))
		rollTable["glancingBlow"] = tempVar - remainingRolls
		tempVar = remainingRolls
	end
	if(attackFront == true and blockEnabled == true) then
		eAvoidance["block"] = eAvoidance["block"] + pSkillDifference * 0.04
		remainingRolls = math.max(0, remainingRolls - eAvoidance["block"])
		rollTable["block"] = tempVar - remainingRolls
		tempVar = remainingRolls
	end
	if(remainingRolls > 0) then
		pCritChance = pCritChance - pSkillDifference * 0.04
		remainingRolls = math.max(0, remainingRolls - ((pHitChance + rollTable["miss"]) * (pCritChance/100)))
		rollTable["crit"] = tempVar - remainingRolls
		tempVar = remainingRolls
		if(isMob == true) then
			remainingRolls = math.max(0, remainingRolls - (((eWpnSkill - pDefSkill) * 2) - 15))
			rollTable["crushingBlow"] = remainingRolls
		end
		rollTable["hit"] = remainingRolls
	end
	return rollTable
end

function getAttackResult(attackTable)
	local rngRanges =math.floor(math.random()*100)
	local weight = 0
	local tableOrder = {"miss","dodge","parry","glancingBlow","block","crit","crushingBlow","hit"}
	for i = 1, #tableOrder do
		weight = weight + attackTable[tableOrder[i]]
		--print(rngRanges,weight,attackTable[tableOrder[i]], tableOrder[i])
		if(rngRanges <= weight) then
			return tableOrder[i]
		end
	end
end

function calculateDamage(pDmgRange, pDmgReduction)
	--local wpnDmg = getDamage(self.playerWeapon[message.player]["damage"])
	pDmgRange["phy"] =  pDmgRange["phy"] * pDmgReduction --(1-(self.bossStats["armor"] / (self.bossStats["armor"] + 400 + 85 * self.bossStats["level"])))
	local damageDone = wpnDmg["phy"] + wpnDmg["fire"] + wpnDmg["frost"] + wpnDmg["arcane"] + wpnDmg["nature"] + wpnDmg["shadow"] + wpnDmg["holy"]
	if(message.type == "Attack") then
		damageDone = damageDone + (self.playerStats[message.player]["ap"] / 14)
		damageDone = math.floor(0.5 + damageDone)
		msg.post("/spritePlayer#spriteP".. message.player, "play_animation", { id = hash("attack") })
		print("Player "..message.player.." hit: "..damageDone.."["..wpnDmg["phy"]..","..wpnDmg["fire"]..","..wpnDmg["frost"]..","..wpnDmg["arcane"]..","..wpnDmg["nature"]..","..wpnDmg["shadow"]..","..wpnDmg["holy"].."]")
	end
end

function calculateDamageReduction(cLevel, cArmor, eLevel)
	reductionPercentage = 0
	if(cLevel < 60) then
		reductionPercentage = min( cArmor / ( cArmor + 400 + 85 * eLevel), 75)
	elseif(cLevel >= 60) then
		reductionPercentage = min( cArmor / ( cArmor + 400 + 85 * ( eLevel + 4.5 * ( eLevel - 59))) , 75)
	end
	print("DR test: character level: "..cLevel.." ; character Armor: "..cArmor.." ; enemy level: "..eLevel.." ; DR%: "..reductionPercentage)
	return reductionPercentage
end


function getRandomDamage(weapon)
	local physDamage, fireDamage, frostDamage, arcaneDamage, natureDamage, shadowDamage, holyDamage = 0,0,0,0,0,0,0
	local schools = {"Physical","Fire","Frost","Arcane","Holy","Shadow","Nature"}
	for i = 1, #schools do
		if(schools[i] == "Physical") then
			physDamage = math.random(tonumber(weapon[schools[i]]["min"]) , tonumber(weapon[schools[i]]["max"]))
		elseif(schools[i] == "Fire") then
			fireDamage = math.random(tonumber(weapon[schools[i]]["min"]) , tonumber(weapon[schools[i]]["max"]))
		elseif(schools[i] == "Frost") then
			frostDamage = math.random(tonumber(weapon[schools[i]]["min"]) , tonumber(weapon[schools[i]]["max"]))
		elseif(schools[i] == "Arcane") then
			arcaneDamage = math.random(tonumber(weapon[schools[i]]["min"]) , tonumber(weapon[schools[i]]["max"]))
		elseif(schools[i] == "Nature") then
			natureDamage = math.random(tonumber(weapon[schools[i]]["min"]) , tonumber(weapon[schools[i]]["max"]))
		elseif(schools[i] == "Shadow") then
			shadowDamage = math.random(tonumber(weapon[schools[i]]["min"]) , tonumber(weapon[schools[i]]["max"]))
		elseif(schools[i] == "Holy") then
			holyDamage = math.random(tonumber(weapon[schools[i]]["min"]) , tonumber(weapon[schools[i]]["max"]))
		end
	end
	return {phy=physDamage, fire=fireDamage,frost=frostDamage,arcane=arcaneDamage,nature=natureDamage,shadow=shadowDamage,holy=holyDamage}
end

function tprint (t, s)
	for k, v in pairs(t) do
		local kfmt = '["' .. tostring(k) ..'"]'
		if type(k) ~= 'string' then
			kfmt = '[' .. k .. ']'
		end
		local vfmt = '"'.. tostring(v) ..'"'
		if type(v) == 'table' then
			tprint(v, (s or '')..kfmt)
		else
			if type(v) ~= 'string' then
				vfmt = tostring(v)
			end
			print(type(t)..(s or '')..kfmt..' = '..vfmt)
		end
	end
end