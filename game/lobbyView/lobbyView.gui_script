
function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("/equipGUI#equipmentGUI", hash("disable"))
	self.currentStat = "None"
	self.currentPlayer = -1
	self.playerStats = {}
	self.playerEquipment = {}
	self.playerEquipProperties = {}
	self.maxPlayers = 5
	self.equipGUIOpen = false
	msg.post(".", hash("updateUI"), {players=self.maxPlayers})
	for x = 1,self.maxPlayers  do
		msg.post("main:/game#savegame", hash("loadGame"), {player=x})
	end
end

function final(self)
	msg.post(".", "release_input_focus")
end

function on_message(self, message_id, message, sender)
	if(message_id == hash("loadDone")) then
		table.insert(self.playerStats,message.data["stats"])
		table.insert(self.playerEquipment, message.data["equipment"])
		self.playerEquipment[message.player]["offhand"]["id"] = 1168
		local equipTable = {}
		for k, v in pairs(self.playerEquipment[message.player]) do
			if(self.playerEquipment[message.player][tostring(k)]["id"] > 0) then
				equipTable[tostring(k)] = self.playerEquipment[message.player][tostring(k)]["id"]
			end
		end
		self.playerEquipProperties[message.player] = equipTable

		local x = message.player
		gui.set_text(gui.get_node("partyP"..x.."/class"), tostring(self.playerStats[x]["class"]) )
		gui.set_text(gui.get_node("partyP"..x.."/level"), tostring(self.playerStats[x]["level"]))
		gui.set_text(gui.get_node("partyP"..x.."/hpmax"), tostring(self.playerStats[x]["hpmax"]))
		gui.set_text(gui.get_node("partyP"..x.."/hpcurr"), tostring(self.playerStats[x]["hpcurr"]))
		gui.set_text(gui.get_node("partyP"..x.."/resmax"), tostring(self.playerStats[x]["resmax"]))
		gui.set_text(gui.get_node("partyP"..x.."/rescurr"), tostring(self.playerStats[x]["rescurr"]))
		gui.set_text(gui.get_node("partyP"..x.."/str"), "STR: "..tostring(self.playerStats[x]["str"]))
		gui.set_text(gui.get_node("partyP"..x.."/agi"), "AGI: "..tostring(self.playerStats[x]["agi"]))
		gui.set_text(gui.get_node("partyP"..x.."/sta"), "STA: "..tostring(self.playerStats[x]["sta"]))
		gui.set_text(gui.get_node("partyP"..x.."/int"), "INT: "..tostring(self.playerStats[x]["int"]))
		gui.set_text(gui.get_node("partyP"..x.."/spr"), "SPR: "..tostring(self.playerStats[x]["spr"]))
		gui.set_text(gui.get_node("partyP"..x.."/mhid"), "MH: "..tostring(self.playerEquipment[x]["mainhand"]["id"]))
		gui.set_text(gui.get_node("partyP"..x.."/ohid"), "OH: "..tostring(self.playerEquipment[x]["offhand"]["id"]))
		gui.set_text(gui.get_node("partyP"..x.."/rid"), "R: "..tostring(self.playerEquipment[x]["ranged"]["id"]))
		gui.set_text(gui.get_node("partyP"..x.."/sp1"), "R: "..tostring(self.playerStats[x]["sp1id"]))
		gui.set_text(gui.get_node("partyP"..x.."/sp2"), "R: "..tostring(self.playerStats[x]["sp2id"]))
		msg.post("main:/game#main", hash("getIcon"), {type="Ability", id=self.playerStats[x]["sp1id"], player=x,slot=1})
		msg.post("main:/game#main", hash("getIcon"), {type="Ability", id=self.playerStats[x]["sp2id"], player=x,slot=2})
		loadEquipment(self,x)
		--msg.post("main:/game#main", hash("getProperties"), {type="Armor" id=self.playerEquipment[x][ player=x})
	elseif(message_id == hash("updateUI")) then
		for i = 1, 5 do
			if(i>message.players) then
				gui.set_enabled(gui.get_node("p"..i), false)
				msg.post("/party#spriteP"..i, hash("disable"))
			end
		end
	elseif(message_id == hash("exitEquipGUI")) then
		self.equipGUIOpen = false
		gui.set_enabled(gui.get_node("partyP2/values"), true)
		gui.set_enabled(gui.get_node("partyP3/values"), true)
		gui.set_enabled(gui.get_node("partyP4/values"), true)
	elseif(message_id == hash("getIcon")) then
		if(message.type == "Ability") then
			gui.set_texture(gui.get_node("partyP"..message.player.."/sp"..message.slot.."icon"), "abilities")
			gui.play_flipbook(gui.get_node("partyP"..message.player.."/sp"..message.slot.."icon"),message.values)
		end
	elseif(message_id == hash("getProperties")) then
		local slot = ""
		if(message.type == "Weapon") then
			if(message.slot == 16) then
				gui.set_texture(gui.get_node("partyP"..message.player.."/mhicon"), "weapons")
				gui.play_flipbook(gui.get_node("partyP"..message.player.."/mhicon"), message.values["icon"])
				slot = "mainhand"
				
			elseif(message.slot == 17) then
				gui.set_texture(gui.get_node("partyP"..message.player.."/ohicon"), "weapons")
				gui.play_flipbook(gui.get_node("partyP"..message.player.."/ohicon"), message.values["icon"])
				slot = "offhand"
			end		
		elseif(message.type == "Armor") then
			if(message.slot == 4) then
				slot = "shirt"
			elseif(message.slot == 7) then
				slot = "legs"
			elseif(message.slot == 8) then
				slot = "feet"
			end
		end
		self.playerEquipment[message.player][slot]["icon"] = message.values["icon"]
		self.playerEquipProperties[message.player][slot] = message.values
		for i = 1, 3 do
			self.playerEquipProperties[message.player][slot]["eids"]["eid"..i] = message.effects[i]
			
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("click") and action.pressed then
		if(gui.pick_node(gui.get_node("startButton"), action.x, action.y)) then
			print("clicked start")
			msg.post("lobbyView", hash("start"), {players=self.maxPlayers})
		elseif(gui.pick_node(gui.get_node("endButton"), action.x, action.y)) then
			print("clicked end")
			msg.post("lobbyView", hash("end"))
		
		end
		for x = 1, self.maxPlayers do
			if(not self.equipGUIOpen and gui.pick_node(gui.get_node("spriteP"..x), action.x, action.y)) then
				print("clicked "..x)
				gui.set_enabled(gui.get_node("partyP2/values"), false)
				gui.set_enabled(gui.get_node("partyP3/values"), false)
				gui.set_enabled(gui.get_node("partyP4/values"), false)
				self.equipGUIOpen = true
				msg.post("/equipGUI#equipmentGUI", hash("enable"))
				--tprint(self.playerEquipProperties[x])
				for k, v in pairs(self.playerEquipProperties[x]) do
					msg.post("/equipGUI#equipmentGUI", hash("equipmentStats"), {stats=self.playerEquipProperties[x][tostring(k)],slot=tostring(k)})
				end
				msg.post("/equipGUI#equipmentGUI", hash("generateIcons"), {icons=self.playerEquipment[x]})
				break
			end
		end
	end
end
--[[
function dirtylarry.set_input(self, node, txt)
	local node_content = gui.get_node(node .. "/content")
	local url = msg.url()
	local key = tostring(url.socket) .. hash_to_hex(url.path) .. hash_to_hex(url.fragment or hash("")) .. node
	dirtylarry.input_nodes[key].data = txt
	gui.set_text(node_content, txt)
end
]]--

function loadEquipment(self,player)
	msg.post("main:/game#main", hash("getProperties"), {type="Weapon", id=self.playerEquipment[player]["mainhand"]["id"], player=player, slot=16})
	msg.post("main:/game#main", hash("getProperties"), {type="Weapon", id=self.playerEquipment[player]["offhand"]["id"], player=player, slot=17})
	msg.post("main:/game#main", hash("getProperties"), {type="Armor", id=self.playerEquipment[player]["shirt"]["id"], player=player, slot=4})
	msg.post("main:/game#main", hash("getProperties"), {type="Armor", id=self.playerEquipment[player]["legs"]["id"], player=player, slot=7})
	msg.post("main:/game#main", hash("getProperties"), {type="Armor", id=self.playerEquipment[player]["feet"]["id"], player=player, slot=8})
end


function tprint (t, s)
	for k, v in pairs(t) do
		local kfmt = '["' .. tostring(k) ..'"]'
		if type(k) ~= 'string' then
			kfmt = '[' .. k .. ']'
		end
		local vfmt = '"'.. tostring(v) ..'"'
		if type(v) == 'table' then
			tprint(v, (s or '')..kfmt)
		else
			if type(v) ~= 'string' then
				vfmt = tostring(v)
			end
			print(type(t)..(s or '')..kfmt..' = '..vfmt)
		end
	end
end